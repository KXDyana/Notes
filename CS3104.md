# CS3104

 ## Introduction:

OS: program that manages computer hardware, also provides a basis for application programs as an intermediary between user and hardware.

User <--> Application/System <--> OS <--> Hardware(resource) 

### Functions of OS:
* interface
* resource allocation
* management of memory, security, etc.

### Main types of OS:
* Batch OS
* Time sharing OS
* Distributed OS
* Network OS
* Real Time OS 
* Multi programming/processing/tasking OS

### Goals of OS:
* Convenience
* Efficiency
* Both (most OS are designed for) 

## Basics

* A modern general-purpose computer system consists of one or more CPUs and a number of device controllers connected through a common bus that provides access to shared memory
* Each device controller is in charge of a specific type of device
* the CPU and the device conrollers can execute concurrently.
*  to ensure orderly access to the shared memory, there need to be a memory controller

### Important Terms
* Bootstrap Program: the initial program that runs when a computer is powered up or rebooted. 
    * stored in ROM
    * must know how to load the OS 
    * must locate and load the OS kernel into memory
* Interrupt: The occurence of an event is usually signalled by an interrupt from a hardware of software.
    * by sending a signal to the CPU (by using the system bus).
* System Call (Monitor Call): software triggers interrupt by using system calls.

When the CPU is interrupted, it stops what it is doing at the moment and immediately transfers execution to a fixed location (where contains the starting address where the service routine of the calling interrupt is located). On completion, the CPU resumes the interrupted computation. 



## Storage Structure

Registers
Cache
Main Memory
Electronic Disk
Magnetic Disk
Optical Disk
Magnetic Tapes

* Volatile: when power is removed, the contents stored loses
* Non-Volatile: retains its contents even when power is removed.

## I/O Structure

* I/O: giving input/getting output
* storage is only one of the many types of I/O devices within a computer
* A modern general-purpose computer system consists of multiple device controllers. Each device controller is in charge of a specific type of device.
* A device controller contains a local buffer storage and a set of specia purpose registers.
* OS have a device driver for each device controller. This driver understands the device controller and persents a uniform interface to the device to the rest of the OS.

### Working of an I/O Operation:
* the device driver loads the registers given by the device controller
* the device controller examines the contents ofthe registers to determine what action to take
* the controller starts to transfer data from the device to its buffer
* the controller informs the driver via an interrupt the the operation is finished
* the driver returns control to the OS.

This form of interrupt-driven I/O is fine for moving small amounts of data, but can produce high overhead when used for large data movement. To solved this, Direct Memory Access (DMA) is used.

* DMA: after setting up buffers, pointers, and counters for I/O device, the controller transfers an entire block of data directly to or from its own buffer storage to memory without interving CPU.

## Computer System Architecture
Types of computer systems based on the number of general purpose processors:
1. single process systems: one main CPU capable of executing a general purpose instruction set including instructions from user processes. Other special purpose processors are also present which perform device specific tasks (such as in a keyboard).
2. multiprocesor systems: also known as parallel systems or tightly coupled systems. Two or more processors in  close communication, sharing the computer bus and sometimes the clock, memory and devices.
    * increased throughput
    * economy of scale
    * increased reliability
3. clustered systems

## Structure

* multiprogramming: increases CPU utilisation by organiszing jobs so that CPU always has one to execute. 
* time sharing: CPU executes multiple jobs by switching among them. The switching occur frequently that the user can interact with each program while it is running.
    * each user has at least one separate program in memory
    * a program loaded into memory and executed is called a process

## Services:

An OS provides an enviroment for applications and programs.


* Command line Interface
* Graphical User Interface

* Program Execution

* I/O Operations

* File System Manipulation

* Communications (between processes)

* Error Detection

* Resource Allocation

* Accounting (keep track of usages)

* Protection and Security


## Interfaces:

### Command Line Interface (Command Interpreter)
allow users to directly enters commands that are to be performed by the OS
* some OS includes the CLI in the kernel. others such as windowsXP/UNIX, CLI is treated as a special program. 
* on some systems with multiple CLI to choose from, the CLI is know as shells. e.g.: bourne shell, C shell, Bourne-again shell(BASH), korn shell, etc. 
    * 1. the code of certain tasks (such as creating a file) is contained in the command interpreter.
    * 2. or,  the interpreter calls the program that can perform the task based on the command.


## System Calls:

System Calls provide an interface to the services made available by an OS.
System call is the programmatic way the program requests a service from the kernel of the OS. Available as routines written in C or C++

### Types of System Calls:

1. Process control
    * load and execute
    * end (halted) and abort when error occurs
    * create process, terminate process
    * get process attributs, set process attributes
    * wait for time
    * wait events, signal event
    * allocate and free memory

2. File Manipulation
    * create file and delete file
    * open and close file
    * read, write and reposition file
    * get and set file attributes

3. Device Management
    * request devices, release device
    * read, write, reposition
    * get and set device attributes
    * logically attach or detach devices

4. Information Maintenance
    * get and set time/date
    * get and set system data
    * get and set process, file and device attributes
    
5. Communications
    * create, delete connections between processes
    * send and recieve messages
    * transfer status information
    * attach or detach remote devices

## System Programs

 Just above Operating Systems, provides a convenient environment for program development and execution. e.g. user interfaces to system calls or gui.

### File Management
* Create, Delete, Copy, Rename, Print, Dunp, List, General Manipulation

### Status Information 
* Ask the System for Date, time, amount of available memory or disk storage, number of users, performance, logging and debugging info, etc.

### File modification
* (built in) text editors
*  search contents of files or transformations of text

## Programming Language support
* Compilers, Assemblers, Debugers and Interpreters for 
* such as C/C++/Java/Visual Basic/PERL

## Program Loading and Execution
* absolute loaders
* relocatable loaders
* linkage editors
* overlay loaders
* debugging systems for high level languages or machine language are needed are well

## Communications 
* creating virtual connections among processes, users and computer systems
* allow users to send messages to another's computer/screens
* browse webpages
* send messages
* log in remotely

## Others
* web browers
* text processors
* spreadsheets
* database systems
* games
   ...


## Design and Inplementation

Design Goals:
Defining goals and Specification
    * Choice of Hardware
    * Types of System

Requirements: 
    * User Goals (easy to use)
    * System Goals (easy to develop and maintain)
    * Mechanism and Policies: mechanisms determine how, policies determine what

Inplementation
* traditionally, OS have been written in assembly
* nowadays, mostly written in C/C++
    therefore, easier to port on different hardwares, understand, debug, more compact, and can be written faster.

## Structure of OS

* Simple Structure:

    ```
    Application Programs
    Resident System Programs
    Device Drivers
    ROM BIOS device drivers (globally accessiable)
    ```
    prone to malicious programs and crashes
    Intel 8088 has no hardware protection

* Monolithic Structure:

    ```
    Users

    Shells and command lines
    Comilter and Interpreters
    System Libraries

    System Call Interface

    Signal, terminal handling, I/O, CPU scheduling...

    terminal controllers, device controllers, memory controllers
    ```
    too many things packed into one level
    difficult to debug

* Layered Structure
    ```
    Layer N: UI

    .
    .
    .
    Layerj 0: Hardware
    ```
    A layer can only use those that are below (through System Calls)
    Not very efficient

* Microkernels

    * kernel only provide system calls
    * all other functionalities are implemented in User mode as seperate applications.
    * suffers from performance due to heavy system overhead

* Modules

    * Object Oriented Approaches
    * Different would be loaded to the kernel when required
    * Each module has a defined protective interface#
    * Each module can directly communicate to another module (not like layered)
    * Modules are dynamically loaded to kernel, so less overhead (compared to microkernels)


## Virtual Machines

Abstract the hardware of a single ocmputer into several different execution enviroments, thereby creating the illution that each seperate exeuction environment is running its own private computer

* Virtual Machine Software: Kernel Mode
* Virtual Mahcine itself: User mode

A virtual machine also has a virtual user mode and a virtual kernel mode (both in user mode)

## OS Generation & System Root

1. design, code and implement an OS for one machine
2. OS to run on any of a class of machines at a variety of machines
3. OS be configured or generated for each specific computer site, where System Generation (SYSGEN) is used
    SYSGEN:
    * what CPU?
    * how much memory?
    * what devices?
    * what OS options are desired?

 ### System Boot
The procedure of starting a computer by loading the kernel.
    * done by a small piece of code known as bootstrap, which locates the kernel
    * bootstrap is in the form of read-only memory (ROM) because RAM is in an unknown state at system startup. ROM needs no initialization and cannot be infected by virus (cannot be modified).

### Firmware
 EPROM: erasable programmable ROM, can be used to update bootstrap and firmware.

When the full bootstrap program is loaded, it can traverse the file system to find the OS kernel and load it into memory, and start its execution. It is only then the system is said to be running




## Process Management

### Process and Threads
* Process: a program in execution
* Thread: the unit of execution within a process    

### Process State
* As process exeuctes, it changes state, defined by current activity

1. New: process created
2. Running: Instructions executed
3. Waiting: process waiting for event to occur
4. Ready: process waiting to be assigned to processor
5. Terminated: process finished execution

## Process Control Block (PCB) (Task Control Block)

```
Process ID (Process number)
Process State
Process counter (address of the next line of instructor)
Registers (been used by this process)
Memory Limits
List of open files
Accounting Info
I/O status Info
...
```                                                                    
## Process Scheduling

Objective: havbe some process running at all times to maximize CPU utilization

* Job Queue: when a process enters the system, they are put into the job queue, consists of all processes in the system.
* Ready Queue: the processes that are residing in main memory and are ready and waiting to be executed

### Context Switch
* Interrupts cause the OS to change a CPU from its current task to run a kernel routine
* When an interrupt occurs, the system  needs to save the current context of the process so that it can be restored. 
* The context is represented in the PCB of the process.
* switching the CPU to another process requires performing a state save of the current process and a state restore of a different process
* context-switch is pure overhead (cost) because the system does no useful work during switching. speed varies from machine to machine and depend on various factors. typically are a few milliseconds.

## Process Creation

a process may create several new processes via a create-process system call. Each children process can in turn create other processes, forming a tree of processes

When new process is created, Two possibilities:
1. the parents continues to execute concurrently with its children
2. the parents waits until some or all of its children have terminated

for address space, Two possibilities:
1. the child is a duplicate of the parent process(same program and data)
2. the child has a new program loaded into it

## Process Termination
* A process terminates when it finishes executing its final statement and asks the operating system to delete it by using the exit() system call.
    * At that point, the process may return a status value (typically int) to its parent process (via the wait() system call)
    * all the resources of the process, including physical and virtual memory, open files, and I/O buffers, are deallocated by the OS.
* A process can also cause the termination of another process via an appropriate system call.
    * usually, such a system call can only be invoked by the parent of the terminated process
    * otherwise, users could arbitrarily kill each other's jobs
    * Reasons to terminate a child: 
        1. the child has exceeded its usage. (via)
        2. the task of the child is no longer required.
        3. the parent is exiting and the OS does not allow a child to continue if the parent is terminated.

## Interprocess Communication

Processes executing cocurrently in the OS may either be independent processes or cooperating processes

* Independent processes: they cannot affect or be affected by the other processes executing in the system
* Coopereating processes: can affect or be affected by the other processes executing in thge system, and would share data
    Reasons for cooperation: Information sharing, computation speedup, modularity, convenience
    2 models:
    1. Shared Memory:
    A region of memory that is shared by cooperating processes is established. processes can then exchange information by reading and writing data to the shared region.
        * shared memory region resides in the address space of the process creating the shared memory segment.
        * normally, two processes cannot access the memory block of each other. 
        * however, shared memory requires that the two processes agree to remove this restriction.
        * e.g. producer-consumer using a buffer
            * unbounded buffer: producer can always produce new items, but consumer must wait
            * bounded buffer: consumer must wait if the buffer is empty, producer must wait if the buffer is full

    2. Message Passing:
    Communication takes place by means of messages exchanged between the cooperating processes. 
        * useful in distributed environments where the communication processes may reside on different computers connected by a network
        * messages sent by a process can be either fixed or variable size
            * fixed size: system implementation is straightforward, but task of programming is more difficult
            * variable size: requires more complex system implementation, but the programming is simpler. 

        * if processes P and Q want to communicate, a communication link must exist between.

            * Naming: 
                * Direct
                    * P and Q must have a way to refer to each other and know each other's name to communicate (symmetry in adderssing) send(P, message) recieve(Q, message)
                    * or only the sender names the recipient to communicate (asymmetry in addressing). send(P, message) recieve(id, message)
                    * Both suffers from limited modularity: changing the identifier of a process may cause problem.
                * Indirect
                    * sending processes send to a mailbox, or port
                    * recieving processes reads from the port
                    * send(A, message) recieve(A, message)
                    * a linked may be associated with more than two processes.
            
            * Synchronization
                * Blocking (synchronous): the sending process is blocked until the message is recieved, the receiver blocks until a message is available
                * Nonblocking (asynchronous): the sending process send the message and resume, the receiving process receive either a valid messaeg or a null

            * Buffering
            Messages exchanged by communicating processes reside in a temporary queue buffer.
                * Zero capacity: the link cannot have any message waiting, so the sender must block until the recipient receives the message.
                * Bounded Capacity: the queue has finite length. if the queue is not full, the sender can continue execution. if the buffer if full, the sender must block until space is available in the queue.
                * Unbounded Capacity: the queue length is not bounded, so the sender never blocks.


## Sockets
Used for communication in client-server systems
* an endpoint for communication
* a pair of processes communicating over a network uses a pair of sockets.
* identified by an IP address concatenated with a port number.
* the server wait for client requests by listening to a specified port. Once a request is recieved, the server accepts a connetion from the client socket.
* servers implementing specific services listen to specific well-known ports (telnet: 23, ftp: 21, http: 80). All ports below 1024 are considered well known and reserved for specific services.
* port number is assigned by the host computer (>1024) following IP address.

## Remote Procedure Calls
a protocol that one program can use to request a service from a program located in another computer on network without understand the network
* very similar to IPC
* message based communication scheme must be used. 
* the message exchanged in RPC are well structured
* each message is addressed to a RPC daemon. each message contains an identifier of the function to execute and the parameter to pass to the function. (functions can be considered as services).
* the function is then executed as requested and output is sent back to requester.
### Issues of RPC and Solutions
1. difference in data representation on client and server machine: use a machine-independent representation of data (external data representation)
2. local procedure calls fail only under extreme circumstances, but RPC can fail or be deplicated because of network errors: the OS ensure that the message are acted on exactly once.
3. the client does not know the port number know on the server: 1. use a fixed port address 2. rendezvous mechanism (matchmaker) daemon on a fixed RPC.


## Threads
* thread ID
* program counter
* register set
* stack
thread shares with other threads belonging to the sam eprocess its code section, data section, and other OS resources.
    Benefits: 
    * responsiveness
    * resource sharing
    * economy
    * utilization of multiprocessor architectures

## Multithreading Models and Hyperthreading

### types of threads:
1. user threads: supported above the kernel and are managed without kernel support
2. kernel threads: supported and managed directly by the OS

Relationships:

1. many to one model (many user threads to one kernel thread)
    * many user threads to one kernel thread
    * thread management is done by thread library in user space, so efficient
    * -entire proess with block if a thread makes a blocking system call
    * -because only one thread can access the kernel at a time, multiple threads are unable to run in parallel.
2. one to one model
    * maps each user thread to a kernel thread
    * provides more concurrency than the many to one model: another thread can run when a thread makes a blocking system call
    * allows multiple threads to run in parallel
    * -creating a user thread requires creating the corresponding kernel thread
    * -the overhead of creating kernel threads can burden the performance of an application, most implementations of this model restricts the number of threads supported by the system.

3. many to may model
    * multiplexes many user threads to a smaller or equal number of kernel threads
    * the number of kernel threads may be specific to a particular application or a particular machine
    * developers can create as many user threads as necessary, and the corresponding kernel thread can run in parallel on a multiprocessor
    * when a thread performs a blocking syscall, another thread can be scheduled for execution

### Hyperthreading, or Simultaneous Multithreading(SMT)
allows their processor cores resources to become multiple logical processors for performance. It enables the processor to execute two threads, or sets of instructions at the same time.

## fork() , exec()

fork(): used to create a seperate, duplicate process
exec(): the program specified in the parameter will replace the entire process, including all threads. same pid will be used.

## Threading Issues

1. does the new process duplicate all the threads or only the thread calling fork()? : two versions
    * When to use when?
    If exec() is called immediately after forking, then duplicating only the calling thread is appropiate (the others are going to be replaced anyways)
    If the process does not call exec() after forking, all threads should be duplicated
2. Thread cancelation: a thread can get canceled before completion (target thread): two schenarios
    1. asynchronous cancellation: one thread immediately terminates the taret thread
    2. deferred cancellation: target thread periodically checks whether it should terminate.

    Difficulties: 
    * resoures allocated to a canceled thread
    * thread is canceled while updating data

    OS often reclaim system resources from canceled thread but will not reclaim all resources.
    Therefore, 2.deferred cancellation is a better approach.

## CPU Scheduling

by switching the CPU among processes, OS can make the computer more productive.

When a process is waiting for I/O event, the CPU just sits idle. the this waiting time is wasted and no useful work is accomplished.
 (CPU execution Burst vs I/O wait Burst)

* Scheduler: scheduler selects a process from the ready proesses
* Dispatcher; gives control of the CPU to the selected process. has to be quick. the time it takes for the dispatcher to stop one process and start running another is known as dispatch latency

Decision happens during the following four circumstances:
1. when a process switches from running state to waiting state
2. when a proceess switches from running state to ready state (interrupt)
3. when a process switches from waiting state to ready state (completion of I/O)
4. process terminates

1,4: non-preemptive
1,2,3,4: preemptive


### Criterias: 

#### CPU Utilisation
the CPU should be kept as busy as possible. conceptually, CPU utilizatino can range from 0% to 100%. usually, it range from 40% tp 90%.

#### Throughput
the number of work that are completed per time unit.

#### Turnaround Time
the sum of time spent waiting to get into memory, waiting in the ready queue, executing on the CPU and doing I/O

#### Waiting Time
the sum of the time spent waiting in the ready queue

#### Response Time
the time it takes to start responding



## Process Synchronization

* Cooperating process: can be affected of affect other processes. can:
    1. share address space
    2. share data through messages
when sharing address space, the data consistency need to be maintained by orderly execution of cooperating processes
* buffer: ersides in a region of memory. a producer can produce while a consumer is concuming another item. the producer and consumer must be synchronized so that the consumer does not try to consume an item that has not been produced yet.
    * Unbounded buffer: consumer have to wait for new items, but the producer can always produce
    * Bounded buffer: consumer must wait if the buffer is empty, producer must wait if the buffer is full
when several processes access and manipulate the same data concurrently and the outcome of the execution depends on the order the access takes place is called race condition.
Hence we need process synchronization.

### Critical Section
critical section: a code segment in which the process may be changing common variables, updating a table, writing a file... when a process is executing in critical section, no other process is to be allowed to execute in its critical section (no two process can execute in their critical sections at the same time). This way processes can cooperate.
#### Rules
1. each process must request permission to enter its critical section
2. the section of code implementing this request is called entry section
3. the critical section is followed by an exit section
4. the maining code is the remainder section.

#### Requirements
1. Mutual exclusion: if process is executing in its critical section, no other processes can be executing in its critical section
2. progress: if no process is executing in its critical section and some processes wish to enter their critical sections, then only those processes that are not executing in their remainder section can participate in the decision on which will enter its criticl section next, and this selection cannot be postponed indefinately
3. bounded waiting: there is a bound, or limit, on the number of times that other processes are allowed to enter their critical section after a process has made a request to enter its ciritcal section and before that request is granted.

#### Peterson's Solution
* a classic solution, software based
* may not work on modern computers, but provides a good algorithmic description of solving the critical section problem and illustrates some of the complexities.
* restricted to two processes that alternate execution between their critical sections and remainder sections.

```C
do{
    flag [iW] = true;
    turn = j;
    while (flag [j] && turn == [j]);    //critical section

    critical section...

    flag [i] = false;

    remainder section...
}while (TRUE)
```










## File System:
Typically the most visible part of OS

1. a collection of files (each containing data)
2. a directory structure(which organises the files)

## File Attributes:

* Name
* Identifier
* Type
* Location
* Size
* Protection
* Time, Date, User Identification

## File Operations:

* Creating
* Writing
* Reading
* Repositioning within a file
* Deleting
* Truncating

## Open Files

* File pointer 
* File-open count
* Disk Location in the file
* Access Rights


Linux: everything is a file

## Types:

* Single-level: everyting has to be uniqie
* Two-level: each user has their own directory. Very secure.
* Tree-structred Directory: more like a modern directory, with root...etc. has a concept of a current directory. No concept of different users directory.
* acyclic directoy (more complicated tree directory) : no cycles, introduces shared files and folders. 