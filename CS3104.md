# CS3104

 ## Introduction:

OS: program that manages computer hardware, also provides a basis for application programs as an intermediary between user and hardware.

User <--> Application/System <--> OS <--> Hardware(resource) 

### Functions of OS:
* interface
* resource allocation
* management of memory, security, etc.

### Main types of OS:
* Batch OS
* Time sharing OS
* Distributed OS
* Network OS
* Real Time OS 
* Multi programming/processing/tasking OS

### Goals of OS:
* Convenience
* Efficiency
* Both (most OS are designed for) 

## Basics

* A modern general-purpose computer system consists of one or more CPUs and a number of device controllers connected through a common bus that provides access to shared memory
* Each device controller is in charge of a specific type of device
* the CPU and the device conrollers can execute concurrently.
*  to ensure orderly access to the shared memory, there need to be a memory controller

### Important Terms
* Bootstrap Program: the initial program that runs when a computer is powered up or rebooted. 
    * stored in ROM
    * must know how to load the OS 
    * must locate and load the OS kernel into memory
* Interrupt: The occurence of an event is usually signalled by an interrupt from a hardware of software.
    * by sending a signal to the CPU (by using the system bus).
* System Call (Monitor Call): software triggers interrupt by using system calls.

When the CPU is interrupted, it stops what it is doing at the moment and immediately transfers execution to a fixed location (where contains the starting address where the service routine of the calling interrupt is located). On completion, the CPU resumes the interrupted computation. 



## Storage Structure

Registers
Cache
Main Memory
Electronic Disk
Magnetic Disk
Optical Disk
Magnetic Tapes

* Volatile: when power is removed, the contents stored loses
* Non-Volatile: retains its contents even when power is removed.

## I/O Structure

* I/O: giving input/getting output
* storage is only one of the many types of I/O devices within a computer
* A modern general-purpose computer system consists of multiple device controllers. Each device controller is in charge of a specific type of device.
* A device controller contains a local buffer storage and a set of specia purpose registers.
* OS have a device driver for each device controller. This driver understands the device controller and persents a uniform interface to the device to the rest of the OS.

### Working of an I/O Operation:
* the device driver loads the registers given by the device controller
* the device controller examines the contents ofthe registers to determine what action to take
* the controller starts to transfer data from the device to its buffer
* the controller informs the driver via an interrupt the the operation is finished
* the driver returns control to the OS.

This form of interrupt-driven I/O is fine for moving small amounts of data, but can produce high overhead when used for large data movement. To solved this, Direct Memory Access (DMA) is used.

* DMA: after setting up buffers, pointers, and counters for I/O device, the controller transfers an entire block of data directly to or from its own buffer storage to memory without interving CPU.

## Computer System Architecture
Types of computer systems based on the number of general purpose processors:
1. single process systems: one main CPU capable of executing a general purpose instruction set including instructions from user processes. Other special purpose processors are also present which perform device specific tasks (such as in a keyboard).
2. multiprocesor systems: also known as parallel systems or tightly coupled systems. Two or more processors in  close communication, sharing the computer bus and sometimes the clock, memory and devices.
    * increased throughput
    * economy of scale
    * increased reliability
3. clustered systems

## Structure

* multiprogramming: increases CPU utilisation by organiszing jobs so that CPU always has one to execute. 
* time sharing: CPU executes multiple jobs by switching among them. The switching occur frequently that the user can interact with each program while it is running.
    * each user has at least one separate program in memory
    * a program loaded into memory and executed is called a process

## Services:

An OS provides an enviroment for applications and programs.


* Command line Interface
* Graphical User Interface

* Program Execution

* I/O Operations

* File System Manipulation

* Communications (between processes)

* Error Detection

* Resource Allocation

* Accounting (keep track of usages)

* Protection and Security


## Interfaces:

### Command Line Interface (Command Interpreter)
allow users to directly enters commands that are to be performed by the OS
* some OS includes the CLI in the kernel. others such as windowsXP/UNIX, CLI is treated as a special program. 
* on some systems with multiple CLI to choose from, the CLI is know as shells. e.g.: bourne shell, C shell, Bourne-again shell(BASH), korn shell, etc. 
    * 1. the code of certain tasks (such as creating a file) is contained in the command interpreter.
    * 2. or,  the interpreter calls the program that can perform the task based on the command.


## System Calls:

System Calls provide an interface to the services made available by an OS.
System call is the programmatic way the program requests a service from the kernel of the OS. Available as routines written in C or C++

### Types of System Calls:

1. Process control
    * load and execute
    * end (halted) and abort when error occurs
    * create process, terminate process
    * get process attributs, set process attributes
    * wait for time
    * wait events, signal event
    * allocate and free memory

2. File Manipulation
    * create file and delete file
    * open and close file
    * read, write and reposition file
    * get and set file attributes

3. Device Management
    * request devices, release device
    * read, write, reposition
    * get and set device attributes
    * logically attach or detach devices

4. Information Maintenance
    * get and set time/date
    * get and set system data
    * get and set process, file and device attributes
    
5. Communications
    * create, delete connections between processes
    * send and recieve messages
    * transfer status information
    * attach or detach remote devices

## System Programs

 Just above Operating Systems, provides a convenient environment for program development and execution. e.g. user interfaces to system calls or gui.

### File Management
* Create, Delete, Copy, Rename, Print, Dunp, List, General Manipulation

### Status Information 
* Ask the System for Date, time, amount of available memory or disk storage, number of users, performance, logging and debugging info, etc.

### File modification
* (built in) text editors
*  search contents of files or transformations of text

## Programming Language support
* Compilers, Assemblers, Debugers and Interpreters for 
* such as C/C++/Java/Visual Basic/PERL

## Program Loading and Execution
* absolute loaders
* relocatable loaders
* linkage editors
* overlay loaders
* debugging systems for high level languages or machine language are needed are well

## Communications 
* creating virtual connections among processes, users and computer systems
* allow users to send messages to another's computer/screens
* browse webpages
* send messages
* log in remotely

## Others
* web browers
* text processors
* spreadsheets
* database systems
* games
   ...


## Design and Inplementation

Design Goals:
Defining goals and Specification
    * Choice of Hardware
    * Types of System

Requirements: 
    * User Goals (easy to use)
    * System Goals (easy to develop and maintain)
    * Mechanism and Policies: mechanisms determine how, policies determine what

Inplementation
* traditionally, OS have been written in assembly
* nowadays, mostly written in C/C++
    therefore, easier to port on different hardwares, understand, debug, more compact, and can be written faster.

## Structure of OS

* Simple Structure:

    ```
    Application Programs
    Resident System Programs
    Device Drivers
    ROM BIOS device drivers (globally accessiable)
    ```
    prone to malicious programs and crashes
    Intel 8088 has no hardware protection

* Monolithic Structure:

    ```
    Users

    Shells and command lines
    Comilter and Interpreters
    System Libraries

    System Call Interface

    Signal, terminal handling, I/O, CPU scheduling...

    terminal controllers, device controllers, memory controllers
    ```
    too many things packed into one level
    difficult to debug

* Layered Structure
    ```
    Layer N: UI

    .
    .
    .
    Layerj 0: Hardware
    ```
    A layer can only use those that are below (through System Calls)
    Not very efficient

* Microkernels

    * kernel only provide system calls
    * all other functionalities are implemented in User mode as seperate applications.
    * suffers from performance due to heavy system overhead

* Modules

    * Object Oriented Approaches
    * Different would be loaded to the kernel when required
    * Each module has a defined protective interface#
    * Each module can directly communicate to another module (not like layered)
    * Modules are dynamically loaded to kernel, so less overhead (compared to microkernels)


## Virtual Machines

Abstract the hardware of a single ocmputer into several different execution enviroments, thereby creating the illution that each seperate exeuction environment is running its own private computer

* Virtual Machine Software: Kernel Mode
* Virtual Mahcine itself: User mode

A virtual machine also has a virtual user mode and a virtual kernel mode (both in user mode)

## OS Generation & System Root

1. design, code and implement an OS for one machine
2. OS to run on any of a class of machines at a variety of machines
3. OS be configured or generated for each specific computer site, where System Generation (SYSGEN) is used
    SYSGEN:
    * what CPU?
    * how much memory?
    * what devices?
    * what OS options are desired?

 ### System Boot
The procedure of starting a computer by loading the kernel.
    * done by a small piece of code known as bootstrap, which locates the kernel
    * bootstrap is in the form of read-only memory (ROM) because RAM is in an unknown state at system startup. ROM needs no initialization and cannot be infected by virus (cannot be modified).

### Firmware
 EPROM: erasable programmable ROM, can be used to update bootstrap and firmware.

When the full bootstrap program is loaded, it can traverse the file system to find the OS kernel and load it into memory, and start its execution. It is only then the system is said to be running




## Process Management

### Process and Threads
* Process: a program in execution
* Thread: the unit of execution within a process    

### Process State
* As process exeuctes, it changes state, defined by current activity

1. New: process created
2. Running: Instructions executed
3. Waiting: process waiting for event to occur
4. Ready: process waiting to be assigned to processor
5. Terminated: process finished execution

## Process Control Block (PCB) (Task Control Block)

```
Process ID (Process number)
Process State
Process counter (address of the next line of instructor)
Registers (been used by this process)
Memory Limits
List of open files
Accounting Info
I/O status Info
...
```                                                                    
## Process Scheduling

Objective: havbe some process running at all times to maximize CPU utilization

* Job Queue: when a process enters the system, they are put into the job queue, consists of all processes in the system.
* Ready Queue: the processes that are residing in main memory and are ready and waiting to be executed

### Context Switch
* Interrupts cause the OS to change a CPU from its current task to run a kernel routine
* When an interrupt occurs, the system  needs to save the current context of the process so that it can be restored. 
* The context is represented in the PCB of the process.






































## File System:
Typically the most visible part of OS

1. a collection of files (each containing data)
2. a directory structure(which organises the files)

## File Attributes:

* Name
* Identifier
* Type
* Location
* Size
* Protection
* Time, Date, User Identification

## File Operations:

* Creating
* Writing
* Reading
* Repositioning within a file
* Deleting
* Truncating

## Open Files

* File pointer 
* File-open count
* Disk Location in the file
* Access Rights


Linux: everything is a file

## Types:

* Single-level: everyting has to be uniqie
* Two-level: each user has their own directory. Very secure.
* Tree-structred Directory: more like a modern directory, with root...etc. has a concept of a current directory. No concept of different users directory.
* acyclic directoy (more complicated tree directory) : no cycles, introduces shared files and folders. 